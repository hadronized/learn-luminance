<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn luminance</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="crate-setup.html">Crate setup</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="chapter_1_2.html"><strong aria-hidden="true">1.2.</strong> Creating a window and preparing graphics code</a></li><li class="chapter-item expanded "><a href="chapter_1_3.html"><strong aria-hidden="true">1.3.</strong> Changing the background color</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Your first triangle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2_1.html"><strong aria-hidden="true">2.1.</strong> What is a triangle?</a></li><li class="chapter-item expanded "><a href="chapter_2_2.html"><strong aria-hidden="true">2.2.</strong> Shady triangle</a></li><li class="chapter-item expanded "><a href="chapter_2_3.html"><strong aria-hidden="true">2.3.</strong> Rendering our triangle</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Wavefront .obj loader</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3_1.html"><strong aria-hidden="true">3.1.</strong> The Wavefront .obj format</a></li><li class="chapter-item expanded "><a href="chapter_3_2.html"><strong aria-hidden="true">3.2.</strong> Defining our vertex type</a></li><li class="chapter-item expanded "><a href="chapter_3_3.html"><strong aria-hidden="true">3.3.</strong> Loading an .obj object</a></li><li class="chapter-item expanded "><a href="chapter_3_4.html"><strong aria-hidden="true">3.4.</strong> The shaders</a></li><li class="chapter-item expanded "><a href="chapter_3_5.html"><strong aria-hidden="true">3.5.</strong> Altering the graphics pipeline</a></li><li class="chapter-item expanded "><a href="chapter_3_6.html"><strong aria-hidden="true">3.6.</strong> Adding light</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn luminance</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="learn-luminance"><a class="header" href="#learn-luminance">Learn luminance</a></h1>
<p>You’re here because you want to learn luminance. Here is the chapter summary.</p>
<h2 id="plan-of-the-book"><a class="header" href="#plan-of-the-book">Plan of the book</a></h2>
<p>The book is written in chapters. It is highly recommended to read them in order, as they will
reference code introduced in previous chapters. Also, each chapter has a dedicated Rust project
containing the final solution <a href="https://github.com/rust-tutorials/learn-luminance/tree/master/examples">here</a>.
Feel free to consult the code if you would like to build each chapters on your own without having
to write the code.</p>
<p>You can compile all chapters by cloning the repository and building them all at once, or build and
run a specific one:</p>
<pre><code class="language-sh">git clone --depth 1 https://github.com/rust-tutorials/learn-luminance
cd learn-luminance/examples

# build everything…
cargo build --release

# …or run the chapter 3
cargo run --release --bin chapter-3 ~/Downloads/torus.obj
</code></pre>
<h2 id="everything-you-should-know-before-jumping-in"><a class="header" href="#everything-you-should-know-before-jumping-in">Everything you should know before jumping in</a></h2>
<p><strong>luminance</strong> is an effort to make graphics rendering simple and elegant. It was originally imagined,
designed and implemented by <a href="https://github.com/phaazon">@phaazon</a> in Haskell (<a href="https://hackage.haskell.org/package/luminance">here</a>)
and eventually ported to Rust in 2016. The core concepts remained the same and the crate has been
slowly evolving ever since. At first used only by <a href="https://github.com/phaazon">@phaazon</a> for his Rust demoscene productions (
example <a href="https://github.com/phaazon/celeri-remoulade">here</a> and
<a href="https://github.com/phaazon/outline-2017-invitro">here</a>, using
<a href="https://crates.io/crates/spectra">spectra</a>) and a bunch of curious peeps, it has started to
gain more visibility among the graphics ecosystem of Rust and bring more people in.</p>
<p>Currently, such an ecosystem is spread into several crates, ideas and people. It is highly
recommended to read the great article about the ecosystem by <a href="https://github.com/icefoxen">@icefoxen</a>,
<a href="https://wiki.alopex.li/AGuideToRustGraphicsLibraries2019">here</a>.</p>
<p>However, <strong>luminance</strong> is a bit different from what it was initially imagined for. People are
looking for an easy-to-use crate, with good abstractions and safe-guards against all the <em>bad</em> and
<em>dangerous</em> graphics API caveats. <strong>luminance</strong> has always been about providing a safe, type-safe
and elegant API (being Haskell-rooted makes it use type systems extensively, for instance) but it has
now a more accurate place in the ecosystem. Where <a href="https://crates.io/crates/gfx-hal">gfx-hal</a> provides you with an experience focused
on down-to-metal performances and an API very similar to <a href="https://www.khronos.org/vulkan">Vulkan</a>’s, <strong>luminance</strong> provides an API
that is, for sure, a bit less low-level — and hence, yes, it’s likely you will not have the same
performances as with <a href="https://crates.io/crates/gfx-hal">gfx-hal</a> (even though no benchmarks have been done so far), and the API is not
<a href="https://www.khronos.org/vulkan">Vulkan</a>-based — but easier to start with, especially if you don’t already have a background
experience with <a href="https://www.khronos.org/opengl">OpenGL</a> or <a href="https://www.khronos.org/vulkan">Vulkan</a>. Furthermore, the API of Vulkan is great to build low-level
primitives, while the audience of <strong>luminance</strong> is a bit higher-level.</p>
<p>The strengths of <strong>luminance</strong> are:</p>
<ul>
<li>Easy to learn: the concepts, based on <a href="https://www.khronos.org/opengl">OpenGL</a>, are applied to <em>graphics</em>, not <em>general-purpose
programming on GPU</em>. Using <strong>luminance</strong> will help you wrap your fingers around what graphics
programming is about and it will help you to, perhaps, jump to lower abstractions like
<a href="https://crates.io/crates/gfx-hal">gfx-hal</a>, if you ever need to.</li>
<li>Performant: by using Rust and being designed around the concept of good performances,
<strong>luminance</strong> should allow you to build nice and fast simulations, animations and video games.
Remember that games you played years ago didn’t have <a href="https://www.khronos.org/vulkan">Vulkan</a> and were impressive nonetheless.
It’s unlikely you will get 100% out of your GPU by using <strong>luminance</strong> since it’s built over
technologies that are not using 100% of your GPU. Unless you need and know exactly why you need
100% of your GPU, you should be <em>just fine™</em>.</li>
<li>Elegant: the design is heavily based on functional programming concepts such as typeclasses,
associated types, singleton types, existentials, contravariant resources, procedural macros,
strong typing, etc. Plus, every bit of possible <em>stateful</em> computations is hidden behind a
system of smart state, removing the need to worry about side-effects. <strong>luminance</strong> still has
mutation (unlike its Haskell version) but the Rust type-system and borrow checker allow for
safe mutations.</li>
<li>Modern: the whole <strong>luminance</strong> ecosystem tries its best to stay up-to-date with Rust evolutions
and features. On the same level, the underneath technologies are kept up-to-date and might even
change if a more modern and more adapted one emerges (<a href="https://www.khronos.org/vulkan">Vulkan</a> might eventually get adopted but
this is just an idea for now).</li>
<li><em>Opinionated enough</em>: a big bet with <strong>luminance</strong> was to make it opinionated, but not too much.
It needs to be opinionated to allow some design constructs to be possible and optimize
performance and allow for extra safety. However, it must not be too much to prevent it to become
a <em>framework</em>. <strong>luminance</strong> is a <em>library</em>, not a <em>framework</em>, meaning that it will adapt to
how <strong>you</strong> think you should design your software, not the other way around. That is limited to
the design of <strong>luminance</strong> but you shouldn’t feel too hands-tied.</li>
</ul>
<p>Some practical information you want to know before learning:</p>
<ul>
<li>The <a href="https://github.com/phaazon/luminance-rs">official GitHub repository</a></li>
<li>The <a href="https://github.com/phaazon/luminance-rs/blob/master/luminance-examples/README.md">luminance examples</a>.
Those are useful when you know what you are looking for and would like to see quickly how to do
it with luminance, or just to have a rough idea of what’s supported.</li>
<li>Spotted a bug? A typo? A performance issue? You need a feature that’s not already available? Shoot it
<a href="https://github.com/phaazon/luminance-rs/issues">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate-setup"><a class="header" href="#crate-setup">Crate setup</a></h1>
<p>First thing first: this book is written against this following luminance crate setup:</p>
<pre><code class="language-toml">luminance = &quot;0.44&quot;
luminance-derive = &quot;0.7&quot;
luminance-front = &quot;0.4&quot;
luminance-glfw = &quot;0.16&quot;
luminance-windowing = &quot;0.10&quot;
</code></pre>
<p>If you are using a version from crates.io that is more recent that this current book, feel free to
ask via an <a href="https://github.com/phaazon/luminance-rs/issues">issue</a> to update the book! The goal is
to keep it as updated as possible, but it might happen it lags a bit behind. Sorry about that.</p>
<p>Even though some other crates exist (windowing, for most), we are not going to focus on them and
will stick to the ones above.</p>
<h2 id="on-version-updates--migrations"><a class="header" href="#on-version-updates--migrations">On version updates / migrations</a></h2>
<p>It is possible that you have started reading some documentation / examples / the book about
luminance at a previous version as the one described here. In that case, you will want to
update your luminance dependencies.</p>
<p>Most of the time, you will be fine, but sometimes, you will not correctly update to the latest
version of luminance. This is due to the fact <code>cargo</code>, by default when invoking <code>cargo update</code>,
will try to satisfy all dependencies in your <code>Cargo.lock</code>. If a dependency is already satisfied,
it will not try to recompute it — that is the case for SemVer Ranges. The result of this is some
cryptic typing or traits errors. In such case, you need to tell <code>cargo</code> to recompute the
dependencies by taking into account the new upper bounds:</p>
<pre><code>cargo update --aggressive
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-luminance-for-newcomers"><a class="header" href="#introduction-to-luminance-for-newcomers">Introduction to luminance for newcomers</a></h1>
<p>Hello there. You’ve hit that page because you’re wondering how <a href="https://crates.io/crates/luminance">luminance</a> is supposed to be used.
You’ve come to the right place. This book is an introduction to <a href="https://crates.io/crates/luminance">luminance</a>, its ways of doing
<em>graphics programming</em> and how to write your first graphics application, the fun way! Its audience
spreads from people who know nothing about graphics programming to people who would like to quickly
and safely build graphics programs.</p>
<p>Let’s not waste time.</p>
<p><img src="./imgs/hello-world.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>You’ll need some prerequisites:</p>
<table><thead><tr><th>Prerequisite</th><th>How to get / resolve</th></tr></thead><tbody>
<tr><td><code>rustup</code></td><td><a href="https://rustup.rs">https://rustup.rs</a></td></tr>
<tr><td>An up to date <code>rustc</code> compiler</td><td><code>rustup update stable &amp;&amp; rustup default stable</code></td></tr>
</tbody></table>
<p>Let’s create a new <em>Rust</em> project in your <code>~/dev</code> directory, for instance. We’ll name the project
<code>luminance-hello-world</code>.</p>
<pre><code>mkdir ~/dev # choose any other directory that suits you
cd ~/dev
cargo new --bin luminance-first-steps
</code></pre>
<p>Then we need to add <a href="https://crates.io/crates/luminance">luminance</a> as a dependency to our project. Edit your <code>Cargo.toml</code> file and
change the <code>[dependencies]</code> section according to the following:</p>
<pre><code class="language-toml">[dependencies]
glfw = &quot;0.41&quot;
luminance = &quot;0.44&quot;
luminance-glfw = &quot;0.16&quot;
luminance-windowing = &quot;0.10&quot;
</code></pre>
<p>Some explanations here:</p>
<ul>
<li><a href="https://crates.io/crates/luminance">luminance</a> is the core crate and contains everything that abstracts over GPU graphics
capabilities. You will mostly use that crate to write graphics code.</li>
<li><a href="https://crates.io/crates/luminance-glfw">luminance-glfw</a> is a <em>platform</em> implementation crate for <a href="https://crates.io/crates/luminance">luminance</a>. There are several crates
available for that, depending on the platform you expect to run on. <a href="https://crates.io/crates/luminance-glfw">luminance-glfw</a> supports a
lot of platforms so you should be good to start (plus it’s pretty easy). Windowing code allows
to ask your system to create a window, handle inputs such as keypresses, mouse movements, touch,
etc. etc.</li>
<li><a href="https://crates.io/crates/luminance-glfw">luminance-windowing</a> is a small crate providing common types <em>platform crates</em> should use to
uniformize as much as possible how windows and contexts get created. This is not mandatory but
highly recommended. <a href="https://crates.io/crates/luminance-glfw">luminance-glfw</a> uses <a href="https://crates.io/crates/luminance-glfw">luminance-windowing</a>.</li>
</ul>
<blockquote>
<p>Note: since version <code>0.9</code>, <a href="https://crates.io/crates/luminance-glfw">luminance-windowing</a> has lost most of its “implementation” symbols.
Platform crates such as <a href="https://crates.io/crates/luminance-glfw">luminance-glfw</a> then don’t re-export the underyling crate’s symbols.
For that reason, you will have to depend on them explicitely, as we do with <a href="https://crates.io/crates/glfw">glfw</a> in this case.</p>
</blockquote>
<p>Optional but highly recommended: install <a href="https://crates.io/crates/cargo-watch">cargo-watch</a>. That tool allows you to have a <code>cargo</code>
loop updating every time a code file in your project changes. You can set it up to re-compile,
re-check, re-test, re-run or even re-doc… Very handy.</p>
<pre><code>cargo install cargo-watch
</code></pre>
<p>You’re now ready to get started.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-a-window-and-preparing-graphics-code"><a class="header" href="#creating-a-window-and-preparing-graphics-code">Creating a window and preparing graphics code</a></h2>
<p>The first thing you want to do is to create a window. This is done via a type you can find in
<a href="https://crates.io/crates/luminance-glfw">luminance-glfw</a>: <code>GlfwSurface</code>. A <em>graphics surface</em> is a common term yet a bit opaque describing
a region of memory that accepts getting rendered to.</p>
<p>Creating a new <em>graphics surface</em> relies on several objects you need to decide values for:</p>
<ul>
<li>The dimensions of the surface. In our case, we will use a screen resolution of <em>960×540</em> just
for the sake of the introduction. You create such dimensions with the <code>WindowDim::Windowed</code>
variant. Others are available, like restricted fullscreen or fullscreen.</li>
<li>The title of the window. Whether it will get displayed depends on your compositor and window
manager but pretty much all of them display the title in the top-level location of your window
as a <em>window decoration property</em>. Titles are encoded as simple <code>&amp;str</code>.</li>
<li>A set of options to tweak the window and system-related properties. For now, that last part is
too advanced and we’ll stick to using the defaults. Use <code>WindowOpt::default()</code>.</li>
</ul>
<p>Getting a <code>GlfwSurface</code> might fail, so you need to handle failures via the <code>Result</code> type.</p>
<p>Once you get your surface, you can start playing with it. How depends on what kind of application
you want to write. For a video game, a simulation, a demo or an animation program, the following
<em>event-render</em> loop is enough. You ask for the event handler to check whether events have occurred
and dequeue them all. Once you’re done, you render a frame, and you loop back.</p>
<p>You quit the application if the window gets closed by the user or if they enter the <em>escape</em> key,
for instance.</p>
<pre><pre class="playground"><code class="language-rust">use glfw::{Action, Context as _, Key, WindowEvent};
use luminance_glfw::GlfwSurface;
use luminance_windowing::{WindowDim, WindowOpt};
use std::process::exit;

fn main() {
  // our graphics surface
  let dim = WindowDim::Windowed {
    width: 960,
    height: 540,
  };
  let surface = GlfwSurface::new_gl33(&quot;Hello, world!&quot;, WindowOpt::default().set_dim(dim));

  match surface {
    Ok(surface) =&gt; {
      eprintln!(&quot;graphics surface created&quot;);
      main_loop(surface);
    }

    Err(e) =&gt; {
      eprintln!(&quot;cannot create graphics surface:\n{}&quot;, e);
      exit(1);
    }
  }
}

fn main_loop(mut surface: GlfwSurface) {
  let mut ctxt = surface.context;
  let events = surface.events_rx;
  let back_buffer = ctxt.back_buffer().expect(&quot;back buffer&quot;);

  'app: loop {
    // handle events
    ctxt.window.glfw.poll_events();
    for (_, event) in glfw::flush_messages(&amp;events) {
      match event {
        WindowEvent::Close | WindowEvent::Key(Key::Escape, _, Action::Release, _) =&gt; break 'app,
        _ =&gt; ()
      }
    }

    // rendering code goes here
    // …

    // swap buffer chains
    ctxt.window.swap_buffers();
  }
}
</code></pre></pre>
<p><code>ctxt.window.glfw.poll_events()</code> allows you to have a look whether you need to dequeue events.
If no event is present in the event queue, that function exits immediately instead of blocking for
an event. That allows you to keep maintaining a constant frame rate.</p>
<p><code>ctxt.window.swap_buffers()</code> takes the graphics <em>back</em> buffer linked to your application and
swaps it with the <em>front</em> buffer, which is the one exposed on your screen. That technique is
commonly referred to as <a href="https://en.wikipedia.org/wiki/Multiple_buffering">double buffering</a>. With <a href="https://crates.io/crates/luminance">luminance</a>, all the renders must eventually end
up in the <em>back</em> buffer so that they get swapped at the end of the main loop. It’s important to
notice — and you will see in future tutorials — that you don’t necessarily have to make your
renders <em>directly</em> into the back buffer. More on that later… ;)</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="changing-the-background-color"><a class="header" href="#changing-the-background-color">Changing the background color</a></h2>
<p>We’re getting to the interesting things. Before trying to render cool rotating cubes, we need to
understand how graphics rendering works in <a href="https://crates.io/crates/luminance">luminance</a>.</p>
<p><a href="https://crates.io/crates/luminance">luminance</a> has a special way of encoding renders. Instead of giving you all the GPU power right
away, it constrains you to pretty much none. That seems insane but you will eventually recognize
that such a way of doing is actually pretty useful. What it means is that by default, you cannot
do anything and you are required to build up types to unlock new GPU features.</p>
<p>To render something, you need several resources. The first resource is a <em>frame buffer</em>. A frame
buffer, encoded with <a href="https://docs.rs/luminance/latest/luminance/framebuffer/struct.Framebuffer.html"><code>Framebuffer</code></a>, is a special GPU resource that holds <em>frames</em>, i.e. the
pixel storage for renders!</p>
<blockquote>
<p>So… is the <em>back</em> buffer you told us earlier some kind of <a href="https://docs.rs/luminance/latest/luminance/framebuffer/struct.Framebuffer.html"><code>Framebuffer</code></a>?</p>
</blockquote>
<p>It’s not <em>some</em> kind: it <strong>is</strong> a <a href="https://docs.rs/luminance/latest/luminance/framebuffer/struct.Framebuffer.html"><code>Framebuffer</code></a>. And guess what: you can access it via the
<code>ctxt.back_buffer()</code> method.</p>
<p>So, let’s make our first cool render and make a color-varying background! First, you will need to
import one symbol from <a href="https://crates.io/crates/luminance">luminance</a>: <a href="https://docs.rs/luminance/latest/luminance/context/trait.GraphicsContext.html"><code>GraphicsContext</code></a>, which is a trait that allows you to run
<a href="https://crates.io/crates/luminance">luminance</a> code and talk to the GPU. We will also use <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a>, from the standard library, to
handle low-precision yet sufficient time points. Add <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.PipelineState.html"><code>PipelineState</code></a> to support graphics
pipelines: more on that later in this chapter.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luminance::context::GraphicsContext as _;
use luminance::pipeline::PipelineState;
use std::time::Instant;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>We don’t need, so far, to have access to the <a href="https://docs.rs/luminance/latest/luminance/context/trait.GraphicsContext.html"><code>GraphicsContext</code></a> symbol — we just need the
implementors.</p>
</blockquote>
<p>Now, let’s get our <em>back</em> buffer.</p>
<pre><pre class="playground"><code class="language-rust">fn main_loop(mut surface: GlfwSurface) {
  let start_t = Instant::now();
  let mut ctxt = surface.context;
  let events = surface.events_rx;
  let back_buffer = ctxt.back_buffer().expect(&quot;back buffer&quot;);

  'app: loop {
    // …
</code></pre></pre>
<p>As you can see, getting the <em>back</em> buffer is piece of cake. Now let’s handle that color.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // rendering code goes here
    // get the current time and create a color based on the time
    let t = start_t.elapsed().as_secs_f32();
    let color = [t.cos(), t.sin(), 0.5, 1.];

    let render = ctxt
      .new_pipeline_gate()
      .pipeline(
        &amp;back_buffer,
        &amp;PipelineState::default().set_clear_color(color),
        |_, _| Ok(()),
      )
      .assume();

    // swap buffer chains
    if render.is_ok() {
      ctxt.window.swap_buffers();
    } else {
      break 'app;
    }
<span class="boring">}
</span></code></pre></pre>
<p>That’s already a lot of code to discuss. <code>ctxt.new_pipeline_gate()</code> gets a lightweight object
that you can use to create <em>graphics pipelines</em> — its type is <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.PipelineGate.html"><code>PipelineGate</code></a>. You can get that type
once and for all and keep it around if you want to but in our case, since we’re only going to create
a single pipeline, we’ll just chain everything.</p>
<p>Then, the <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.PipelineGate.html#method.pipeline"><code>PipelineGate::pipeline</code></a> function, applied to the <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.PipelineGate.html"><code>PipelineGate</code></a> object, creates a graphics
pipeline. A graphics pipeline is just a strongly typed description of what a GPU should do in order
to render <em>things</em> into a <a href="https://docs.rs/luminance/latest/luminance/framebuffer/struct.Framebuffer.html"><code>Framebuffer</code></a>. You can picture pipelines as <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>s in which each node
represents a given resource sharing and leaves are actual renders.</p>
<p>In our case, we don’t want to render anything, we just want to modify the <em>back</em> buffer background
color. That is done with the arguments you pass to <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.PipelineGate.html#method.pipeline"><code>PipelineGate::pipeline</code></a>. The first one is the
frame buffer to render to. In our case, it’s our <em>back</em> buffer.</p>
<p>The second argument is the <em>pipeline state</em> (<a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.PipelineState.html"><code>PipelineState</code></a> to use when running our pipeline.
Everytime you perform a render into a frame buffer, you <em>need</em> to provide such an object, which
contains the color to use when clearing the framebuffer’s color buffers. It is possible to tell
<a href="https://crates.io/crates/luminance">luminance</a> not to clear color buffers but this is off topic.</p>
<p>The third and last argument is a <em>closure</em> you need to pass. That closure will be called as soon as
the frame buffer is ready to receive a render. All this code is fully <em>synchronous</em> though, so
lifetimes are enforced. In our case, since we’re not interested into making any actual render,
we just pass a closure that does nothing – it simply returns <code>Ok(())</code>. More on its two arguments later.</p>
<p>The <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.Render.html#method.assume"><code>assume()</code></a> method, defined on <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.Render.html"><code>Render</code></a>, is an <em>identity function</em> (i.e. it simply forwards
its argument). It doesn’t seem very useful, but there’s a small trick: it explicitely states that
its argument has a type which error types are <a href="https://docs.rs/luminance/latest/luminance/pipeline/enum.PipelineError.html"><code>PipelineError</code></a>. It’s indeed possible to use a
different error type in the graphics pipeline, but in our case, we will just use the default one
and <em>assume</em> the pipeline is typed with it. It gives hint to the type system to use this error type
and remove any ambiguity, then.</p>
<p>You should obtain a window with a varying color, such as the following screenshot.</p>
<p><img src="./imgs/hello-world.png" alt="" /></p>
<p>The complete code is:</p>
<pre><pre class="playground"><code class="language-rust">use glfw::{Action, Context as _, Key, WindowEvent};
use luminance::context::GraphicsContext as _;
use luminance::pipeline::PipelineState;
use luminance_glfw::GlfwSurface;
use luminance_windowing::{WindowDim, WindowOpt};
use std::process::exit;
use std::time::Instant;

fn main() {
  let dim = WindowDim::Windowed {
    width: 960,
    height: 540,
  };
  let surface = GlfwSurface::new_gl33(&quot;Hello, world!&quot;, WindowOpt::default().set_dim(dim));

  match surface {
    Ok(surface) =&gt; {
      eprintln!(&quot;graphics surface created&quot;);
      main_loop(surface);
    }

    Err(e) =&gt; {
      eprintln!(&quot;cannot create graphics surface:\n{}&quot;, e);
      exit(1);
    }
  }
}

fn main_loop(surface: GlfwSurface) {
  let start_t = Instant::now();
  let mut ctxt = surface.context;
  let events = surface.events_rx;
  let back_buffer = ctxt.back_buffer().expect(&quot;back buffer&quot;);

  'app: loop {
    // handle events
    ctxt.window.glfw.poll_events();
    for (_, event) in glfw::flush_messages(&amp;events) {
      match event {
        WindowEvent::Close | WindowEvent::Key(Key::Escape, _, Action::Release, _) =&gt; break 'app,
        _ =&gt; (),
      }
    }

    // rendering code goes here
    // get the current time and create a color based on the time
    let t = start_t.elapsed().as_secs_f32();
    let color = [t.cos(), t.sin(), 0.5, 1.];

    let render = ctxt
      .new_pipeline_gate()
      .pipeline(
        &amp;back_buffer,
        &amp;PipelineState::default().set_clear_color(color),
        |_, _| Ok(()),
      )
      .assume();

    // swap buffer chains
    if render.is_ok() {
      ctxt.window.swap_buffers();
    } else {
      break 'app;
    }
  }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-your-first-triangle"><a class="header" href="#render-your-first-triangle">Render your first triangle</a></h1>
<p>Now you know how to create a <em>graphics pipeline</em> and change the <em>frame buffer</em> background color.
Let’s get to more exciting things, shall we?</p>
<p>We are going to render a single triangle on screen. It will have its <em>vertices</em> with a different
color (one red, one green, one blue) and will be filled by a color gradient between the three
colors. It’s the <em>Hello, world!</em> of graphics libraries.</p>
<p><img src="./imgs/your_first_triangle.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-triangle"><a class="header" href="#what-is-a-triangle">What is a triangle?</a></h1>
<p>Everyone knows what a triangle is… but what is a triangle on your GPU? In <a href="https://crates.io/crates/luminance">luminance</a>, a triangle
can be <em>represented</em> in lots of ways. In our case:</p>
<ul>
<li>A triangle has three vertices.</li>
<li>We decide that each vertex has a position in <strong>2D</strong>, represented by two floating point values on
32-bit.</li>
<li>Each vertex has a color, represented as RGB on 8-bit unsigned integers.</li>
</ul>
<p>The first thing to do is to create… types. You will see throughout this book that <a href="https://crates.io/crates/luminance">luminance</a> is
heavily type-oriented. Don’t freak out. <a href="https://crates.io/crates/luminance">luminance</a> requires you to define your type in a way it can
acknowledge how vertices’ data are formed. The following, for instance, will not work:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Position = (f32, f32);
type RGB = (u8, u8, u8);
type Vertex = (Position, RGB);
<span class="boring">}
</span></code></pre></pre>
<p>But the real vertex definition is very, very similar. Hang on.</p>
<h2 id="defining-your-vertex-type"><a class="header" href="#defining-your-vertex-type">Defining your vertex type</a></h2>
<p>In order to define our vertex type, we need to create a <code>struct</code> that will implement the <a href="https://docs.rs/luminance/latest/luminance/vertex/trait.Vertex.html"><code>Vertex</code></a>
trait. That trait requires various information to be provided by the implementor. You don’t have
to worry about those, because a crate exists to automatically implement such a trait:
<a href="https://crates.io/crates/luminance-derive">luminance-derive</a>.</p>
<p>First thing first: add <a href="https://crates.io/crates/luminance-derive">luminance-derive</a> to your project’s <code>[dependencies]</code> section:</p>
<pre><code class="language-toml">luminance-derive = &quot;0.7&quot;
</code></pre>
<p>Simple. One last thing: when you will use the <code>Vertex</code> derive annotation, you will have to provide
a <em>vertex semantics</em> type, implementing the <a href="https://docs.rs/luminance/latest/luminance/vertex/trait.Semantics.html"><code>Semantics</code></a> trait. Again, you don’t have to implement
such a trait by hand: <a href="https://crates.io/crates/luminance-derive">luminance-derive</a> will handle all that for you.</p>
<p>Vertex semantics are a way to tell <a href="https://crates.io/crates/luminance">luminance</a> what the relationship between <em>all</em> objects you
intend to create and the way they will be rendered is. In our case, we just only need two
semantics: <em>vertex positions</em> and <em>vertex colors</em>. Let’s create our semantics type by using a
proc-macro derive from <a href="https://crates.io/crates/luminance-derive">luminance-derive</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luminance_derive::Semantics;
<span class="boring">}
</span></code></pre></pre>
<p>Our proc-macro derive, yay. Let’s use it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, Debug, Semantics)]
pub enum VertexSemantics {
  #[sem(name = &quot;position&quot;, repr = &quot;[f32; 2]&quot;, wrapper = &quot;VertexPosition&quot;)]
  Position,
  #[sem(name = &quot;color&quot;, repr = &quot;[u8; 3]&quot;, wrapper = &quot;VertexRGB&quot;)]
  Color,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Woah, that’s a lot of new syntax!</p>
</blockquote>
<p>Indeed, let’s dig the syntax:</p>
<ul>
<li>The <code>Semantics</code> derive annotation marks an <code>enum</code> as being representative of <em>vertex semantics</em>.
Currently, nothing else than <code>enum</code> is supported.</li>
<li>The type implementing <code>Semantics</code> must also implement <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>, <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> and <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>.</li>
<li>Each variant of the <code>enum</code> represents a distinct <em>vertex semantics</em>.</li>
<li>The syntax <code>#[sem(..)]</code> provides several mandatory information:
<ul>
<li>The <code>name = &quot;position&quot;</code> annotation gives <a href="https://crates.io/crates/luminance">luminance</a> a way to recognize the semantics in
<em>shader stages</em>. You don’t have to worry about what it means so far but keep in mind that
that identifier must be unique.</li>
<li><code>repr = &quot;[f32; 2]&quot;</code> tells which is the underlying expected type of the semantics. That
constructs a strongly-typed assumption about the semantics. A <code>&quot;position&quot;</code> is a 2D <code>f32</code>.
Period. You have a large list of types you can use here but you are limited to the implementors
of <a href="https://docs.rs/luminance/latest/luminance/vertex/trait.VertexAttrib.html"><code>VertexAttrib</code></a>.</li>
<li>The <code>wrapper = &quot;VertexPosition&quot;</code> annotation generates a new type called <code>VertexPosition</code> and
in scope in the module you declared the <code>enum</code>. That type is one of the only ones which are
recognized as being usable with the <code>Semantics</code> <code>enum</code> you just declared — it implements the
<a href="https://docs.rs/luminance/latest/luminance/vertex/trait.HasSemantics.html"><code>HasSemantics</code></a> trait for which <code>HasSemantics::Sem = VertexSemantics</code>. This type is also
equipped with some functions and implementors, such as <code>new</code>, <code>From / Into</code>, etc.</li>
</ul>
</li>
</ul>
<p>All of this might be a bit confusing; let’s clarify even further. When you declare an <code>enum</code>
annotated with <code>#[derive(Copy, Clone, Debug, Semantics)]</code>, <a href="https://crates.io/crates/luminance-derive">luminance-derive</a> does automatically
implement <a href="https://docs.rs/luminance/latest/luminance/vertex/trait.Semantics.html"><code>Semantics</code></a> for you and generates as many types as variants in your <code>enum</code>. Those types
represent <em>vertex attributes</em> types you will be able to use to construct types that will correctly
implement the <a href="https://docs.rs/luminance/latest/luminance/vertex/trait.Vertex.html"><code>Vertex</code></a> trait.</p>
<p>Talking about <a href="https://docs.rs/luminance/latest/luminance/vertex/trait.Vertex.html"><code>Vertex</code></a>, let’s go and define our vertex type. The <code>Vertex</code> derive annotation works
on both <code>struct</code>s and tuple-<code>struct</code>. Import the <code>Vertex</code> proc-macro derive first:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luminance_derive::{Semantics, Vertex};
<span class="boring">}
</span></code></pre></pre>
<p>And then define your <code>Vertex</code> type (it’s possible to use the same typename because proc-macro won’t
clash with types):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug, Vertex)]
#[vertex(sem = &quot;VertexSemantics&quot;)]
pub struct Vertex {
  #[allow(dead_code)]
  position: VertexPosition,

  #[allow(dead_code)]
  #[vertex(normalized = &quot;true&quot;)]
  color: VertexRGB,
}
<span class="boring">}
</span></code></pre></pre>
<p>A new syntax! So:</p>
<ul>
<li>The <code>Vertex</code> derive annotation marks a <code>struct</code> as being a valid <em>vertex</em> type. Currently, only
<code>struct</code> with fields and tuple-<code>struct</code> are supported.</li>
<li>The <code>#[vertex(sem = &quot;VertexSemantics&quot;)]</code> provides a mapping to a type that represents your
<em>vertex semantics</em>.</li>
<li>Each field must have a type that implements <code>HasSemantics&lt;Sem = VertexSemantics&gt;</code> in that case.
Don’t forget about the <code>wrapper</code> types that got generated with the <code>Semantics</code> derive: those
types are valid as fields’ types here.</li>
<li>The special <code>#[vertex(normalized = &quot;true&quot;)]</code> annotation marks a field as being <em>normalized</em>.
Normalized fields make sense when the field is of an integral type, such as <code>[u8; 3]</code>, which is
<em>unsigned integral</em>. When trying to fetch normalized vertex attributes, a <em>vertex stage</em> will get
normalized floating point numbers (lying in <code>[0.; 1.]</code>) instead of the typical e.g. <code>[0; 255]</code>.</li>
</ul>
<p>And we are good to go as our vertex type is now live!</p>
<blockquote>
<p>Some notes: the generated wrapper types have some useful methods and implementors. You can easily
get a list by running <code>cargo doc --open</code>.</p>
</blockquote>
<h2 id="defining-a-triangle"><a class="header" href="#defining-a-triangle">Defining a triangle</a></h2>
<p>A triangle is just three points — three vertices. Let’s define them.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const VERTICES: [Vertex; 3] = [
  Vertex::new(
    VertexPosition::new([-0.5, -0.5]),
    VertexRGB::new([255, 0, 0]),
  ),
  Vertex::new(
    VertexPosition::new([0.5, -0.5]),
    VertexRGB::new([0, 255, 0]),
  ),
  Vertex::new(
    VertexPosition::new([0., 0.5]),
    VertexRGB::new([0, 0, 255])
  ),
];
<span class="boring">}
</span></code></pre></pre>
<p>It’s that simple.</p>
<h2 id="the-final-part-of-the-recipe-gpu-tessellations"><a class="header" href="#the-final-part-of-the-recipe-gpu-tessellations">The final part of the recipe: GPU tessellations</a></h2>
<blockquote>
<p>Tessellations?</p>
</blockquote>
<p>In <a href="https://crates.io/crates/luminance">luminance</a>, everything that has a <em>vertex</em> or that <em>must be rendered</em> is done via a
<em>tessellation</em> as described by the <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a> type. GPU tessellations provide information about:</p>
<ul>
<li>The nature of the topology of the underlying <em>vertex mesh</em>. That is, zero, one or several
buffers describing the raw topology of the mesh.</li>
<li>The way vertices are linked to each other. That is done via several ways that are going to be
explored in this book, but so far, we’ll stick to <em>primitive modes</em>, encoded via the <a href="https://docs.rs/luminance/latest/luminance/tess/enum.Mode.html"><code>Mode</code></a>
type.</li>
<li>And a lot of cool features you should be impatient to discover, but everything happens to those
who wait. ;)</li>
</ul>
<p>Creating a <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a> will upload our vertices to the GPU so that we have an object (i.e. <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a>) to
manipulate and render our triangle. However, one does not simply create a <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a>: we need
<a href="https://docs.rs/luminance/latest/luminance/tess/struct.TessBuilder.html"><code>TessBuilder</code></a>, which follows the [builder pattern].</p>
<p><img src="./imgs/one-does-not-simply-create-tess-without-builder.jpg" alt="" /></p>
<p>Let’s see the code to create our <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a> via <a href="https://docs.rs/luminance/latest/luminance/tess/struct.TessBuilder.html"><code>TessBuilder</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luminance::tess::Mode;
<span class="boring">}
</span></code></pre></pre>
<p>Then:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // at the beginning of main_loop
  let triangle = ctxt
    .new_tess()
    .set_vertices(&amp;VERTICES[..])
    .set_mode(Mode::Triangle)
    .build()
    .unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>If you don’t specify the <a href="https://docs.rs/luminance/latest/luminance/tess/enum.Mode.html"><code>Mode</code></a>, the <a href="https://docs.rs/luminance/latest/luminance/tess/struct.TessBuilder.html"><code>TessBuilder</code></a> defaults to <a href="https://docs.rs/luminance/latest/luminance/tess/enum.Mode.html#variant.Point"><code>Mode::Point</code></a>, which will not
connect your vertices between them and will leave three independent points on your screen. Also,
in a production application, you shouldn’t use <code>.unwrap()</code> but instead propagate the error or
treat it.</p>
<p>We have everything we need to represent our triangle on GPU with <a href="https://crates.io/crates/luminance">luminance</a>. Let’s go on and see
how we can render it into our frame buffer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shady-triangle"><a class="header" href="#shady-triangle">Shady triangle</a></h1>
<p><a href="https://crates.io/crates/luminance">luminance</a> is not a framework nor a video game engine. By default, it comes with zero data set.
Hence, there is nothing <em>per se</em> that provides <em>materials</em> or that kind of concept. You will have
to craft them yourself and that is what we are going to do in this section.</p>
<p>Remember our pipeline creation from the first chapter? We needed to provide a closure taking two
arguments. It’s time to explain you what those arguments are for. Let’s take the pipeline
definition again:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctxt.new_pipeline_gate().pipeline(
  &amp;back_buffer,
  &amp;PipelineState::default().set_clear_color(color),
  |_, _| Ok(()),
).assume();
<span class="boring">}
</span></code></pre></pre>
<p>And rewrite it by using the arguments:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctxt.new_pipeline_gate().pipeline(
  &amp;back_buffer,
  &amp;PipelineState::default().set_clear_color(color),
  |pipeline, mut shd_gate| Ok(()),
  // …
}).assume();
<span class="boring">}
</span></code></pre></pre>
<p>The <code>pipeline</code> argument here represents a <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.Pipeline.html"><code>Pipeline</code></a> and <code>shd_gate</code> a <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html"><code>ShadingGate</code></a>.</p>
<h3 id="the-graphics-pipeline"><a class="header" href="#the-graphics-pipeline">The graphics pipeline</a></h3>
<p>The <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.Pipeline.html"><code>Pipeline</code></a> object you’re given represents a <em>graphics pipeline</em>. It allows you to notify
the GPU about scarce resources you’re about to use or perform specific tasks related to such
resources. That is pretty advanced so we will just ignore that object and will leave it to <code>_</code>
for now.</p>
<p>More on <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.Pipeline.html"><code>Pipeline</code></a> in a future chapter.</p>
<h3 id="the-shading-gate"><a class="header" href="#the-shading-gate">The shading gate</a></h3>
<p><a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html"><code>ShadingGate</code></a> represents a way to <em>shade</em> things. Shading means, like if you had a paper and color
pens, filling in shapes with colors. <a href="https://crates.io/crates/luminance">luminance</a> works the same way. However, you have no pen and no
default algorithm to fill your triangle. You need to instruct <a href="https://crates.io/crates/luminance">luminance</a> how to. And to do that,
you need a small digression in the world of <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">GLSL</a> and shaders.</p>
<p>A <em>shader stage</em> is a piece of code that runs on a GPU. Its inputs and how frequently it will be
called heavily depend on its kind. The following table gives a better understanding.</p>
<blockquote>
<p>Here, frequency doesn’t refer to a frequency in time, but a frequency in GPU resources. You will
get what it means below.</p>
</blockquote>
<table><thead><tr><th>Shader stage type</th><th>Mandatory?</th><th>What it’s for</th><th>Inputs</th><th>Running frequency</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.VertexShader"><code>VertexShader</code></a></td><td>Yes.</td><td>Transforming vertices at the beginning of the pipeline.</td><td>Vertex attributes.</td><td>Once for every vertices comprised in our <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a>.</td></tr>
<tr><td><a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.TessellationControlShader"><code>TessellationControlShader</code></a></td><td>No.</td><td>Determines how much a <em>primitive patch</em> must be tessellated.</td><td>Abstract patches.</td><td>At least once for every <em>abstract patches</em> flowing from the <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.VertexShader"><code>VertexShader</code></a>.</td></tr>
<tr><td><a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.TessellationEvaluationShader"><code>TessellationEvaluationShader</code></a></td><td>No.</td><td>Transform tessellated patches.</td><td>Abstract patches.</td><td>At least once for every <em>abstract patches</em> flowing from the <em>tessellator</em> that has followed the <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.TessellationControlShader"><code>TessellationControlShader</code></a>.</td></tr>
<tr><td><a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.GeometryShader"><code>GeometryShader</code></a></td><td>No.</td><td>Map, filter, add and transform <em>primitives</em>.</td><td>Primitive attributes.</td><td>Once for each primitive patch flowing out from either the <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.VertexShader"><code>VertexShader</code></a> or <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.TessellationEvaluationShader"><code>TessellationEvaluationShader</code></a>.</td></tr>
<tr><td><a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.FragmentShader"><code>FragmentShader</code></a></td><td>Yes.</td><td>Transform <em>rasterized</em> fragments into <em>render target output(s)</em>.</td><td>Rasterized fragment.</td><td>Once for each fragments rasterized from the previous stages.</td></tr>
</tbody></table>
<p>Basically, you need to provide some valid <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">GLSL</a> code for, at least, the <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.VertexShader"><code>VertexShader</code></a> and the
<a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.FragmentShader"><code>FragmentShader</code></a>.</p>
<blockquote>
<p>As cool as they are, we will not dig (for this chapter) into the other types of shader stages.</p>
</blockquote>
<p>Assembling <em>shader stages</em> yields a <em>shader program</em>, which type is <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a>. Such an object
can then be used with our <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html"><code>ShadingGate</code></a> to shade our triangle! What we need to do here is to
write:</p>
<ul>
<li>A <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.VertexShader"><code>VertexShader</code></a> in <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">GLSL</a> that will simply forward the vertex attributes to the next stage
so that this information is available later.</li>
<li>A <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.FragmentShader"><code>FragmentShader</code></a> that will read this information and output a single color for each pixel
of the ~screen~ frame buffer.</li>
</ul>
<h3 id="the-vertex-shader"><a class="header" href="#the-vertex-shader">The vertex shader</a></h3>
<blockquote>
<p>If you don’t know <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">GLSL</a>, you’re going to have some hard times but we will try to explain
everything.</p>
</blockquote>
<p>A vertex shader runs for every vertices in your <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a>. In our case, we don’t really want to do
anything useful with the vertices: we just want them to be drawn on our 2D screen. However, we need
to tell the next stage (i.e. <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.FragmentShader"><code>FragmentShader</code></a>) about what makes a <em>vertex</em>. That manual operation
must be written in the <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.VertexShader"><code>VertexShader</code></a>.</p>
<p>In your project, add the <code>src/vs.glsl</code> file and fill it with:</p>
<pre><code class="language-glsl">// those are our vertex attributes
in vec2 position;
in vec3 color;

// this is the output of the vertex shader (we could have had several ones)
out vec3 v_color;

void main() {
  // simply forward the color
  v_color = color;

  // mandatory; tell the GPU to use the position vertex attribute to put the vertex in space
  gl_Position = vec4(position, 0., 1.);
}
</code></pre>
<h3 id="the-fragment-shader"><a class="header" href="#the-fragment-shader">The fragment shader</a></h3>
<p>A fragment shader runs for every <em>rasterized</em> fragments from the render of your <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a>. Basically,
your GPU transforms the geometry, projects it, performs several complex operations we end up with
rasterized data. Rasterized data means to discretize all the vertex attributes. The discretization
process is based on the resolution of the <em>render target</em> — i.e. the frame buffer outputs.
Rasterized data will perform, for instance, interpolation of your vertex attributes so that each
texel (i.e. a frame buffer / texture <em>pixel</em>) has its version of the vertex attribute.</p>
<p>A rasterized triangle can be imagined as a collection of thousands of texels representing a
triangle. Each and everyone of them will store a color, in our case, so that it’s easy to render
that on a screen, store in an image, etc.</p>
<p>In your project, add the <code>src/fs.glsl</code> file with the following content:</p>
<pre><code class="language-glsl">// this was the vertex shader output; it’s now our (rasterized and interpolated) input!
in vec3 v_color;

// we will output a single color
out vec4 frag_color;

void main() {
  // KISS
  frag_color = vec4(v_color, 1.0);
}
</code></pre>
<p>In your <code>src/main.rs</code>, add the following lines:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const VS_STR: &amp;str = include_str!(&quot;vs.glsl&quot;);
const FS_STR: &amp;str = include_str!(&quot;fs.glsl&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>And we’re good to go. Let’s create a <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a>. We’ll first need to import the type.</p>
<h3 id="the-shader-program"><a class="header" href="#the-shader-program">The shader program</a></h3>
<p>A <em>shader program</em> is a collection of <em>shader stages</em>, connecting them to each other. It’s like
building an actual program by gluing functions to each other. <a href="https://crates.io/crates/luminance">luminance</a> has a very opinionated
idea of what a GPU shader program is and should be. That opinion will be explained in a future
chapter. Let’s focus on the simple stuff first.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luminance::shader::Program;
<span class="boring">}
</span></code></pre></pre>
<p>Then, right before your loop:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut program = ctxt
    .new_shader_program::&lt;VertexSemantics, (), ()&gt;()
    .from_strings(VS_STR, None, None, FS_STR)
    .unwrap()
    .ignore_warnings();
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, you need to provide the <em>vertex semantics type</em> you defined earlier. That enables
<a href="https://crates.io/crates/luminance">luminance</a> to check whether your <em>shader program</em> is compatible with the <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a> you intend to use
it with… at compile-time. Ignore the two <code>()</code>, we’ll discuss that later. However, notice the use
of the <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.BuiltProgram.html#method.ignore_warnings"><code>BuiltProgram::ignore_warnings</code></a> method: it gives you the actual <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> by ignoring any
<em>warnings</em> that might have happened while creating the shader program. You can inspect them if you
want to but for the purpose of this example, you will not need to. Also, keep in mind that those
are only warnings that wouldn’t cause your program to behave in a weird way.</p>
<blockquote>
<p>On a general note, <a href="https://crates.io/crates/luminance">luminance</a> is heavily type-driven. Familiarize yourself with how you can
drive behavior with types (the <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/generics.html">turbofish syntax</a>, for instance, will be useful).</p>
</blockquote>
<h3 id="the-shading-node"><a class="header" href="#the-shading-node">The shading node</a></h3>
<p>The next step is to create a new <em>shading node</em> in your graphics pipeline. This is done via the
<a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html"><code>ShadingGate</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let render = ctxt
      .new_pipeline_gate()
      .pipeline(
        &amp;back_buffer,
        &amp;PipelineState::default().set_clear_color(color),
        |_, mut shd_gate| {
          shd_gate.shade(&amp;mut program, |_, _, mut rdr_gate| {
            // …
          })
        },
      )
      .assume();
<span class="boring">}
</span></code></pre></pre>
<p>You can see we are getting access to a new type of <em>gate</em> here: a <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.RenderGate.html"><code>RenderGate</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-our-triangle"><a class="header" href="#rendering-our-triangle">Rendering our triangle</a></h1>
<p>A <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.RenderGate.html"><code>RenderGate</code></a> allows to create <em>render nodes</em>. Such nodes will share <a href="https://docs.rs/luminance/latest/luminance/render_state/struct.RenderState.html"><code>RenderState</code></a>s for all
lower nodes in the graphics pipeline. We will see what we can do with <a href="https://docs.rs/luminance/latest/luminance/render_state/struct.RenderState.html"><code>RenderState</code></a> in a future
chapter. Currently, we will just use the default one.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luminance::render_state::RenderState;
<span class="boring">}
</span></code></pre></pre>
<p>And alter your pipeline:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let render = ctxt
      .new_pipeline_gate()
      .pipeline(
        &amp;back_buffer,
        &amp;PipelineState::default().set_clear_color(color),
        |_, mut shd_gate| {
          shd_gate.shade(&amp;mut program, |_, _, mut rdr_gate| {
            rdr_gate.render(&amp;RenderState::default(), |mut tess_gate| {
              // …
            })
          })
        },
      )
      .assume();
<span class="boring">}
</span></code></pre></pre>
<p>We’re almost there. We’re getting a <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.TessGate.html"><code>TessGate</code></a>, allowing us to render actual tessellations. In
order to do so, we will need to create a [<code>TessView</code>] out of our <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a>. That enables to slice
GPU tessellation on the fly for free. In our case, we want the whole thing (the whole triangle).
Some convenient implementors exist, and there’s one allowing to get a <code>TessView</code> from a <code>&amp;Tess</code>.</p>
<blockquote>
<p>You can also use the [<code>View</code>] trait to do such a thing.</p>
</blockquote>
<p>Let’s go and finish it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let render = ctxt
      .new_pipeline_gate()
      .pipeline(
        &amp;back_buffer,
        &amp;PipelineState::default().set_clear_color(color),
        |_, mut shd_gate| {
          shd_gate.shade(&amp;mut program, |_, _, mut rdr_gate| {
            rdr_gate.render(&amp;RenderState::default(), |mut tess_gate| {
              tess_gate.render(&amp;triangle)
            })
          })
        },
      )
      .assume();
<span class="boring">}
</span></code></pre></pre>
<p>Compile and run the code. You should see something similar to this:</p>
<p><img src="imgs/your_first_triangle.png" alt="" /></p>
<p>The complete code:</p>
<pre><pre class="playground"><code class="language-rust">use glfw::{Action, Context as _, Key, WindowEvent};
use luminance::context::GraphicsContext as _;
use luminance::pipeline::PipelineState;
use luminance::render_state::RenderState;
use luminance::tess::Mode;
use luminance_derive::{Semantics, Vertex};
use luminance_glfw::GlfwSurface;
use luminance_windowing::{WindowDim, WindowOpt};
use std::process::exit;
use std::time::Instant;

#[derive(Copy, Clone, Debug, Semantics)]
pub enum VertexSemantics {
  #[sem(name = &quot;position&quot;, repr = &quot;[f32; 2]&quot;, wrapper = &quot;VertexPosition&quot;)]
  Position,
  #[sem(name = &quot;color&quot;, repr = &quot;[u8; 3]&quot;, wrapper = &quot;VertexRGB&quot;)]
  Color,
}

#[derive(Clone, Copy, Debug, Vertex)]
#[vertex(sem = &quot;VertexSemantics&quot;)]
pub struct Vertex {
  #[allow(dead_code)]
  position: VertexPosition,

  #[allow(dead_code)]
  #[vertex(normalized = &quot;true&quot;)]
  color: VertexRGB,
}

const VERTICES: [Vertex; 3] = [
  Vertex::new(
    VertexPosition::new([-0.5, -0.5]),
    VertexRGB::new([255, 0, 0]),
  ),
  Vertex::new(
    VertexPosition::new([0.5, -0.5]),
    VertexRGB::new([0, 255, 0]),
  ),
  Vertex::new(VertexPosition::new([0., 0.5]), VertexRGB::new([0, 0, 255])),
];

const VS_STR: &amp;str = include_str!(&quot;vs.glsl&quot;);
const FS_STR: &amp;str = include_str!(&quot;fs.glsl&quot;);

fn main() {
  let dim = WindowDim::Windowed {
    width: 960,
    height: 540,
  };
  let surface = GlfwSurface::new_gl33(&quot;Hello, world!&quot;, WindowOpt::default().set_dim(dim));

  match surface {
    Ok(surface) =&gt; {
      eprintln!(&quot;graphics surface created&quot;);
      main_loop(surface);
    }

    Err(e) =&gt; {
      eprintln!(&quot;cannot create graphics surface:\n{}&quot;, e);
      exit(1);
    }
  }
}

fn main_loop(surface: GlfwSurface) {
  let mut ctxt = surface.context;
  let events = surface.events_rx;
  let back_buffer = ctxt.back_buffer().expect(&quot;back buffer&quot;);
  let start_t = Instant::now();

  let triangle = ctxt
    .new_tess()
    .set_vertices(&amp;VERTICES[..])
    .set_mode(Mode::Triangle)
    .build()
    .unwrap();

  let mut program = ctxt
    .new_shader_program::&lt;VertexSemantics, (), ()&gt;()
    .from_strings(VS_STR, None, None, FS_STR)
    .unwrap()
    .ignore_warnings();

  'app: loop {
    // handle events
    ctxt.window.glfw.poll_events();
    for (_, event) in glfw::flush_messages(&amp;events) {
      match event {
        WindowEvent::Close | WindowEvent::Key(Key::Escape, _, Action::Release, _) =&gt; break 'app,

        _ =&gt; (),
      }
    }

    // rendering code goes here
    // get the current time and create a color based on the time
    let t = start_t.elapsed().as_secs_f32();
    let color = [t.cos(), t.sin(), 0.5, 1.];

    let render = ctxt
      .new_pipeline_gate()
      .pipeline(
        &amp;back_buffer,
        &amp;PipelineState::default().set_clear_color(color),
        |_, mut shd_gate| {
          shd_gate.shade(&amp;mut program, |_, _, mut rdr_gate| {
            rdr_gate.render(&amp;RenderState::default(), |mut tess_gate| {
              tess_gate.render(&amp;triangle)
            })
          })
        },
      )
      .assume();

    // swap buffer chains
    if render.is_ok() {
      ctxt.window.swap_buffers();
    } else {
      break 'app;
    }
  }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wavefront-obj-loader"><a class="header" href="#wavefront-obj-loader">Wavefront .obj loader</a></h1>
<p>In the previous chapter, we saw how to render a single triangle by using several concepts:</p>
<ul>
<li><a href="https://docs.rs/luminance/latest/luminance/vertex/trait.Vertex.html"><code>Vertex</code></a> and <a href="https://docs.rs/luminance/latest/luminance/vertex/trait.Semantics.html"><code>Semantics</code></a> types to define what vertices can be.</li>
<li><a href="https://docs.rs/luminance/latest/luminance/tess/enum.Mode.html"><code>Mode</code></a>, <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a> and its <a href="https://docs.rs/luminance/latest/luminance/tess/struct.TessBuilder.html"><code>TessBuilder</code></a> companion type to build GPU tessellations.</li>
<li><a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.VertexShader"><code>VertexShader</code></a>, <a href="https://docs.rs/luminance/latest/luminance/shader/stage/enum.Type.html#variant.FragmentShader"><code>FragmentShader</code></a> and <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> to create shaders.</li>
<li><a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.Pipeline.html"><code>Pipeline</code></a>, <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html"><code>ShadingGate</code></a>, <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.RenderGate.html"><code>RenderGate</code></a> and <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.TessGate.html"><code>TessGate</code></a> to create graphics pipelines.</li>
</ul>
<p>In this chapter, we will see how we can write a [Wavefront .obj] viewer.</p>
<p><img src="./imgs/suzanne_lit.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-wavefront-obj-format"><a class="header" href="#the-wavefront-obj-format">The Wavefront .obj format</a></h1>
<blockquote>
<p><em>A what?!</em></p>
</blockquote>
<p>The <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront .obj</a> file format is a format that describes 3D data in a very simple manner. It is
a text format that has been around the graphics and 3D industry for a while now. Open and widely
adopted by the graphics community, it’s often criticized for its lack of modern features.
Nevertheless, it is a very popular format, simple to parse and contains enough information for a lot
of applications. Applications such as Z-Brush, Blender or 3Ds Max have full support for such a
format so it’s a perfect match for our community concerns.</p>
<p>Because we do not care about the actual format definition nor implementing a parser, we will use the
<a href="https://crates.io/crates/wavefront_obj">wavefront_obj</a> crate for that purpose:</p>
<pre><code class="language-toml">wavefront_obj = &quot;10&quot;
</code></pre>
<p>That format is basically divided into several parts (non-exhaustive):</p>
<ul>
<li>Materials definitions. We are currently not interested by those and we will just ignore them.</li>
<li>Vertex definitions. Vertices are spread out by attributes and each vertex attribute is declared
on one single line. Currently, we are interested in:
<ul>
<li>3D positions, with an optional fourth argument.</li>
<li>UV mapping coordinates. Those are used for texturing. More on that later.</li>
<li>Normals. Normals are very important to perform lighting computations, vertex displacement, etc.</li>
</ul>
</li>
<li>Face definitions. A face is just a list of numbers indexing the previously declared vertices to
form either <em>triangles</em> or <em>quads</em>.</li>
<li>Object definitions. Faces and vertices can be gathered in named objects, but we do not care about
that so far.</li>
</ul>
<p>So what we will want to do here is to load a <code>.obj</code> object and actually display it with
<a href="https://crates.io/crates/luminance">luminance</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-our-vertex-type"><a class="header" href="#defining-our-vertex-type">Defining our vertex type</a></h1>
<p>The first thing to do is to define the kind of geometry our renderer will support. In the first
place, we are not interested into supporting texturing nor even lighting, just raw geometry. We
will then only need the position.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luminance_derive::{Semantics, Vertex};

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Semantics)]
pub enum VertexSemantics {
  #[sem(name = &quot;position&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexPosition&quot;)]
  Position,
}

#[derive(Clone, Copy, Debug, Vertex)]
#[vertex(sem = &quot;VertexSemantics&quot;)]
struct Vertex {
  position: VertexPosition,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Notice that we now have a 3D point instead of a 2D point.</p>
</blockquote>
<p>You should be familiar with that code by now. We will just add this for future use:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type VertexIndex = u32;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><a href="https://crates.io/crates/luminance">luminance</a> supports several kinds of indices. <code>u32</code> is more than enough for our current use case
but you never know.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-an-obj-object"><a class="header" href="#loading-an-obj-object">Loading an .obj object</a></h1>
<p>This is not really the purpose of this book but you actually need the following code in order to get the rest.
So here it is. Refer to the <a href="https://crates.io/crates/wavefront_obj">wavefront_obj</a> crate for further details. The idea here is that we define our
own <code>Obj</code> type with our own representation of what an object is. We then use <a href="https://crates.io/crates/wavefront_obj">wavefront_obj</a> to
load one object and convert it to our representation. Simple.</p>
<blockquote>
<p>Note: we also use the <a href="https://crates.io/crates/try-guard">try-guard</a> crate to convert boolean expressions to <em>try</em> values.</p>
</blockquote>
<p>However, before going any further, we are going to need to introduce a new crate: <a href="https://crates.io/crates/luminance-front">luminance-front</a>.</p>
<h2 id="luminance-front"><a class="header" href="#luminance-front">luminance-front</a></h2>
<p>The examples you saw so far are simple enough they don’t require you to explicitly put type
ascriptions about the scarce resources you use. However, as soon as you need to pass them around,
you are going to hit a problem.</p>
<p><a href="https://crates.io/crates/luminance">luminance</a> — the crate — is a backend agnostic graphics API. It means that it doesn’t know which
backend it will be executed with. That information is selected by a <em>platform</em> crate — in our case,
<a href="https://crates.io/crates/luminance-glfw">luminance-glfw</a>, which in its turn depends on a <em>backend crate</em> — <a href="https://crates.io/crates/luminance-gl">luminance-gl</a> here. A type
such as <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a> gets its first type variable, <code>B</code>, replaced by the backend type. You didn’t notice
that because the examples from the previous chapters didn’t require passing such types around, but
now we are going to need to annotate functions’ signatures with <a href="https://crates.io/crates/luminance">luminance</a> types, and then, with
backend types.</p>
<p>You have three options:</p>
<ol>
<li>You can decide to bring in <a href="https://crates.io/crates/luminance-gl">luminance-gl</a> in your <code>Cargo.toml</code> and use the backend type that is
exported from there — a.k.a. <code>GL33</code> in our case. This will allow you to use it where backend
types are expected, but this will prevent you from using anything else but OpenGL 3.3. It ties
your code to a backend implementation.</li>
<li>You could continue declaring and passing the <code>B</code> type variable. That is a sane option if you are
writing a luminance crate or a middleware library, but it’s going to lead to not very comfortable
types to read. For instance, if you want to be able to call the <code>TessBuilder::set_vertices</code>
method, the list of constaints, types and bounds you need to add (from
<code>luminance::backend::tess</code>) is likely to discourage you.</li>
<li>You could use <a href="https://crates.io/crates/luminance-front">luminance-front</a>. The goal of this crate is to select a backend type at
compile-time and provide type aliases to remove the need to annotate functions and types with
backend types. This is a much more comfortable situation and it scales / adapts to the
compilation targets and feature gates you set in your <code>Cargo.toml</code>.</li>
</ol>
<p>We are going to use <a href="https://crates.io/crates/luminance-front">luminance-front</a> to demonstrate how easy the crate is. Basically, it will
re-export all the types from <a href="https://crates.io/crates/luminance">luminance</a>, replacing the <code>B</code> type variables (where it appears) by
the right backend type. The backend type, found at <code>luminance_front::Backend</code>, can be used if you
still need to constrain some code (typical with <code>C: GraphicsContext</code>).</p>
<p>Also, in order to make things more coherent and convenient, <a href="https://crates.io/crates/luminance-front">luminance-front</a> re-exports symbols
which don’t have the <code>B</code> type variables (it simply forwards them), so that you can remove
<code>luminance</code> from your <code>use</code> statements and make them more uniform.</p>
<blockquote>
<p>Note: keep in mind that if you use [luminance-derive], as it depends on <a href="https://crates.io/crates/luminance">luminance</a>, you will
still need to have to include <a href="https://crates.io/crates/luminance">luminance</a> in your <code>Cargo.toml</code>.</p>
</blockquote>
<p>Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">luminance-front = &quot;0.3&quot;
</code></pre>
<h2 id="loading-wavefront-objects"><a class="header" href="#loading-wavefront-objects">Loading Wavefront objects</a></h2>
<p>Loading a .obj is not really part of this book, but we’ll provide the code so that you don’t have
to struggle too much. With <a href="https://crates.io/crates/luminance-front">luminance-front</a>, you will notice that the platform crate is still up
to us to decide. So if we want to be able to work for any platform crates, we need to constrain
the platform with the backend type <a href="https://crates.io/crates/luminance-front">luminance-front</a> would have selected for us. We can do that
with <code>luminance_front::Backend</code>. If <code>C</code> is the type of the platform (in our case it’s the one from
<code>GlfwSurface</code> but it’s a good practice to be able to adapt to any), then the following is required
to perform <a href="https://crates.io/crates/luminance">luminance</a> operations:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>where C: GraphicsContext&lt;Backend = Backend&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Then, loading is just a matter of following <a href="https://crates.io/crates/wavefront_obj">wavefront_obj</a>’s API:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luminance_front::context::GraphicsContext;
use luminance_front::tess::{Tess, TessError};
use luminance_front::Backend;
use std::fs::File;
use std::io::Read as _;
use std::path::Path;
use try_guard::verify;
use wavefront_obj::obj;

// …

#[derive(Debug)]
struct Obj {
  vertices: Vec&lt;Vertex&gt;,
  indices: Vec&lt;VertexIndex&gt;,
}

impl Obj {
  fn to_tess&lt;C&gt;(self, ctxt: &amp;mut C) -&gt; Result&lt;Tess&lt;Vertex, VertexIndex, (), Interleaved&gt;, TessError&gt;
  where
    C: GraphicsContext&lt;Backend = Backend&gt;,
  {
    ctxt
      .new_tess()
      .set_mode(Mode::Triangle)
      .set_vertices(self.vertices)
      .set_indices(self.indices)
      .build()
  }

  fn load&lt;P&gt;(path: P) -&gt; Result&lt;Self, String&gt;
  where
    P: AsRef&lt;Path&gt;,
  {
    let file_content = {
      let mut file = File::open(path).map_err(|e| format!(&quot;cannot open file: {}&quot;, e))?;
      let mut content = String::new();
      file.read_to_string(&amp;mut content).unwrap();
      content
    };
    let obj_set = obj::parse(file_content).map_err(|e| format!(&quot;cannot parse: {:?}&quot;, e))?;
    let objects = obj_set.objects;

    verify!(objects.len() == 1).ok_or(&quot;expecting a single object&quot;.to_owned())?;

    let object = objects.into_iter().next().unwrap();

    verify!(object.geometry.len() == 1).ok_or(&quot;expecting a single geometry&quot;.to_owned())?;

    let geometry = object.geometry.into_iter().next().unwrap();

    println!(&quot;loading {}&quot;, object.name);
    println!(&quot;{} vertices&quot;, object.vertices.len());
    println!(&quot;{} shapes&quot;, geometry.shapes.len());

    // build up vertices; for this to work, we remove duplicated vertices by putting them in a
    // map associating the vertex with its ID
    let mut vertex_cache: HashMap&lt;obj::VTNIndex, VertexIndex&gt; = HashMap::new();
    let mut vertices: Vec&lt;Vertex&gt; = Vec::new();
    let mut indices: Vec&lt;VertexIndex&gt; = Vec::new();

    for shape in geometry.shapes {
      if let obj::Primitive::Triangle(a, b, c) = shape.primitive {
        for key in &amp;[a, b, c] {
          if let Some(vertex_index) = vertex_cache.get(key) {
            indices.push(*vertex_index);
          } else {
            let p = object.vertices[key.0];
            let position = VertexPosition::new([p.x as f32, p.y as f32, p.z as f32]);
            let vertex = Vertex { position };
            let vertex_index = vertices.len() as VertexIndex;

            vertex_cache.insert(*key, vertex_index);
            vertices.push(vertex);
            indices.push(vertex_index);
          }
        }
      } else {
        return Err(&quot;unsupported non-triangle shape&quot;.to_owned());
      }
    }

    Ok(Obj { vertices, indices })
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically, calling <code>Obj::load(path)</code> here will get us a <code>Result&lt;Obj, String&gt;</code>. We can then just
convert it to a <a href="https://docs.rs/luminance/latest/luminance/tess/struct.Tess.html"><code>Tess</code></a> for <a href="https://crates.io/crates/luminance">luminance</a> to process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-shaders"><a class="header" href="#the-shaders">The shaders</a></h1>
<p>Again, we need to define our shaders. But in our case, we are going to need to write <em>slightly</em>
more complicated shaders. See, a 3D viewer requires objects to be <em>projected</em> onto one’s screen. In
the previous chapters, we just rendered a triangle in 2D. Here we are talking 3D. Going from a three
dimensional world to a screen (i.e. 2D) requires some operations to do.</p>
<h2 id="projection-matrix"><a class="header" href="#projection-matrix">Projection matrix</a></h2>
<p>Going from a 3D space to a 2D space always implies losing information on the fly in the process.
This is really easy to picture by taking an easier example. Imagine someone moving around Earth.
They have a position, including an altitude. Now imagine you want to <em>project</em> their positions onto
the up axis, giving the altitude at which those persons are. One very easy way to do that is to
simply <em>drop</em> all the other components of their positions and just retain their “up” component. For
instance, if we have a position as:</p>
<pre><code>position = (x, y, z)
</code></pre>
<p>And we say that <code>y</code> is the component of the up-axis, we can define our projection as such:</p>
<pre><code>project_altitude((_, y, _)) = y
</code></pre>
<p>Going from a 3D space to a screen can be done in <em>several</em> ways. The way done above was <em>3D -&gt; 1D</em>
but here, <em>3D -&gt; 2D</em> can be achieved by several ideas. For instance, an <em>orthogonal projection</em> is
a kind of projection that preserves parallels. A <em>perspective projection</em> is a projection that
implies distorting the vertices so that the <em>field of view</em> is respected. You are typically used to
that kind of projection when playing a video game or watching a movie, for instance. Or just taking
a picture!</p>
<h2 id="the-perspective-matrix"><a class="header" href="#the-perspective-matrix">The perspective matrix</a></h2>
<p>Any way, no more theory talk. In order to use a perspective matrix and project our loaded object,
we will be using the <a href="https://crates.io/crates/cgmath">cgmath</a> crate. Many exist that can do the job but I really like the simplicity
and raw speed of <a href="https://crates.io/crates/cgmath">cgmath</a>.</p>
<pre><code class="language-toml">cgmath = &quot;0.17&quot;
</code></pre>
<p>We will be using several symbols from it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cgmath::{perspective, EuclideanSpace, Matrix4, Point3, Rad, Vector3};
<span class="boring">}
</span></code></pre></pre>
<p>Don’t get scared about the heavy-math symbol names. What you must know, however, is this:</p>
<ul>
<li>In graphics applications, we use <a href="https://en.wikipedia.org/wiki/Linear_algebra">linear algebra</a> <em>a lot</em>. You don’t have to know everything by
heart, obviously, but having a linear algebra background will highly help for sure.</li>
<li>From linear algebra, we’re mostly interested into these concepts:
<ul>
<li>Vector spaces. The most important one. You should know how you are supposed to add vectors and
how to scale them by a given scalar number and how to compute the sine of the angle between two
vectors. More prerequisites will come but for today that’s enough about vector spaces.</li>
<li>Matrices. Unlike the movie, they’re not entertainment and can encode lots of other math
concepts, among linear maps and manipulating vector spaces in a compact and powerful way. We
use them for combining translations, scaling, rotations, <a href="https://en.wikipedia.org/wiki/Shear_matrix">shearing</a>, etc.</li>
<li>Quaternions. Scary name for a cute structure. Quaternions are 4-components numbers that can
represent a lot of things. In our case, we like to use them to represent arbitrary rotations of
φ angle (often expressed in radians) around a given unit axis (a unit axis is a 3D vector that
has been <a href="http://mathworld.wolfram.com/NormalizedVector.html">normalized</a> — i.e. its length is 1).</li>
</ul>
</li>
</ul>
<p>I know, I know, that’s a lot of new concepts completely unrelated to <a href="https://crates.io/crates/luminance">luminance</a>. But you need them
and, trust me, it’s not that hard.</p>
<p>Back to our code now.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOVY: Rad&lt;f32&gt; = Rad(std::f32::consts::FRAC_PI_2);
const Z_NEAR: f32 = 0.1;
const Z_FAR: f32 = 10.;

// …

// in the main_loop function, before the actual loop

let projection = perspective(FOVY, width as f32 / height as f32, Z_NEAR, Z_FAR);
<span class="boring">}
</span></code></pre></pre>
<p>This defines a projection matrix with a <em>field of view</em> set to <em>π ÷ 2</em> (wich represents a field of
view of 90°), with an <em>aspect ratio</em> defines by the division between the width and height of the
framebuffer we’re rendering into and with two special parameters, <code>Z_NEAR</code> and <code>Z_FAR</code>. Those are
<em>clipping</em> parameters defining a <em>frustrum</em> object. Everything outside the frustrum won’t be
visible when asking to render.</p>
<p><img src="https://i0.wp.com/www.lighthouse3d.com/wp-content/uploads/2011/04/vf.gif?w=405" alt="" /></p>
<blockquote>
<p>Image taken from <a href="http://www.lighthouse3d.com/tutorials/view-frustum-culling">here</a>.</p>
</blockquote>
<h2 id="the-view-matrix"><a class="header" href="#the-view-matrix">The view matrix</a></h2>
<p>A single projection matrix <em>projects</em> 3D coordinates on 2D coordinates with a given perspective but
the 3D coordinate system is still left unchanged. What it means is that projecting only will place
you in a situation where you’re still at the origin (i.e. <code>(0, 0, 0)</code>) looking in the <em>forward</em>
direction. What the forward vector is depends on which canonical system you decide to use, but in
our case, it’s a <a href="https://en.wikipedia.org/wiki/Right-hand_rule">right-handed system</a>. The <em>X</em> unit axis goes from left to right of your screen;
the <em>Y</em> unit axis goes from down to up your screen and the <em>Z</em> axis (also called <em>depth</em>) goes from
<em>inside your screen</em> towards your face.</p>
<p>Because we will just place the loaded object at the origin, we will want to slightly offset our
position and view direction so that we can actually see the object. Again, <a href="https://crates.io/crates/cgmath">cgmath</a> provides us with
the right <em>transformation matrix</em> for this.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let view = Matrix4::&lt;f32&gt;::look_at(Point3::new(2., 2., 2.), Point3::origin(), Vector3::unit_y());
<span class="boring">}
</span></code></pre></pre>
<p>We will then be at the 3D point <code>(2, 2, 2)</code> and will look at the origin, the <em>Y</em> unit axis being
considered the <em>up</em> axis.</p>
<h2 id="declaring-the-matrices-in-the-shader"><a class="header" href="#declaring-the-matrices-in-the-shader">Declaring the matrices in the shader</a></h2>
<p>Next step is to actually use those matrices. In order to do so, we need to do two things:</p>
<ul>
<li>Use the matrices in the shader code.</li>
<li>Tell <a href="https://crates.io/crates/luminance">luminance</a> about the existence of those matrices in the shaders so that we can update them.</li>
</ul>
<h3 id="glsl-matrices"><a class="header" href="#glsl-matrices">GLSL matrices</a></h3>
<p>Let’s start from the <em>vertex shader</em> we used in the previous chapter.</p>
<pre><code class="language-glsl">// those are our vertex attributes
in vec2 position;
in vec3 color;

// this is the output of the vertex shader (we could have had several ones)
out vec3 v_color;

void main() {
  // simply forward the color
  v_color = color;

  // mandatory; tell the GPU to use the position vertex attribute to put the vertex in space
  gl_Position = vec4(position, 0., 1.);
}
</code></pre>
<p>In our case, we don’t have vertex colors anymore and we will likely just set a constant color to
start with. Plus, now the point is in 3D, not 2D.</p>
<pre><code class="language-glsl">in vec3 position; // 3D point!

void main() {
  gl_Position = vec4(position, 1.);
}
</code></pre>
<p>The problem is: it’s easy for the GPU to render 2D coordinates because there’s nothing to project:
your screen is already using a 2D space coordinate system. However, how should we handle our 3D
vertices?</p>
<p>You already have the answer: the <em>projection</em> matrix. That matrix will just turn your 3D vertices
into 2D vertices. In order to use it, you need to declare a <em>shader uniform variable</em>. Uniforms are
special variables which values are set by the application before or after a render command. When
a render command is issued, it is not possible to change the value anymore until the render command
has finished. You can picture those uniform values as <em>constants over a draw call</em>. Some graphics
APIs call those <em>constant buffers</em> for that reason.</p>
<p>Let’s add one we’ll call <code>projection</code>. You declare them at global scope, just next to <code>in</code> and
<code>out</code> declarations. They can be declared in any shader stage that needs to manipulate them.</p>
<pre><code class="language-glsl">uniform mat4 projection;
</code></pre>
<p>It’s as simple as that. In our case, <code>projection</code> is a 4×4 matrix that will be supplied by the
application.</p>
<p>In order to be projected, a point must be multiplied by a matrix. Let’s just project our 3D point
then:</p>
<pre><code class="language-glsl">gl_Position = projection * vec4(position, 1.);
</code></pre>
<p>All of this might be a bit weird or awkward at first because it’s highly linked to how vector spaces
and linear algebra work but you’ll have to trust me on this (or read some linear algebra theory!).</p>
<p>Now let’s add the <em>view</em> matrix, allowing us to slightly offset the camera in the scene:</p>
<pre><code class="language-glsl">uniform mat4 view;
</code></pre>
<p>Simple, right?</p>
<pre><code class="language-glsl">gl_Position = projection * view * vec4(position, 1.);
</code></pre>
<p>So, some explications here. We multiply <code>view</code> and <code>position</code> first because <code>view</code> is a matrix that
<em>transforms</em> a 3D point into another 3D point. You can picture that as a <em>basis transformation</em>.
Then we want to project that transformed point, so we multiply by the <code>projection</code> at the very left.</p>
<p>That’s all for the GLSL code. Nothing else to do: our 3D point is now projected onto our screen by
having gone through two basis change:</p>
<ul>
<li>A <em>3D -&gt; 3D</em> linear transformation to <em>move the camera around</em>.</li>
<li>A <em>3D -&gt; 2D</em> projection to introduce perspective.</li>
</ul>
<h3 id="the-uniform-interface"><a class="header" href="#the-uniform-interface">The uniform interface</a></h3>
<p>In order for your application to actually update and send those matrices to the GPU, you need to
declare them and change the way the shader <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> works. A special concept must be used here:
<a href="https://docs.rs/luminance/latest/luminance/shader/program/trait.UniformInterface.html">uniform interfaces</a>.</p>
<p>A uniform interface is a typed contract between the GLSL code compiled and linked in a shader
<a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> and what you are supposed to do with it. This powerful abstraction allows you to specify,
via a type, a set of <em>variables</em> that are available in the GLSL code and that you can get access to
as soon as your <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> gets shading things. The way you do this is a multi-step yet simple
process:</p>
<ol>
<li>You define a <code>struct</code> that holds the GPU variables. Those are called <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Uniform.html"><code>Uniform</code></a>.</li>
<li>You implement the <a href="https://docs.rs/luminance/latest/luminance/shader/program/trait.UniformInterface.html"><code>UniformInterface</code></a> trait for that type. If you don’t want to get too much
into the details of that trait, you can use <a href="https://crates.io/crates/luminance-derive">luminance-derive</a> to implement the trait very easily.
That’s what we are going to do.</li>
<li>You set your <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> type variable setting its <em>uniform interface</em> to the type you just
created.</li>
<li>When you use a <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html"><code>ShadingGate</code></a> to shade objects, you have access to your <em>uniform interface</em> and
can then update GPU variables there.</li>
</ol>
<p>Why cannot you create and handle the uniform interface by yourself? The thing is: that concept
<em>must</em> be <a href="https://en.wikipedia.org/wiki/Functor#Covariance_and_contravariance">contravariant</a>, because allowing you to handle such objects around while they depend on
the current GPU context and state would be highly unsafe.</p>
<p>Let’s create such a type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, UniformInterface)]
struct ShaderInterface {
  #[uniform(unbound)]
  projection: Uniform&lt;[[f32; 4]; 4]&gt;,
  #[uniform(unbound)]
  view: Uniform&lt;[[f32; 4]; 4]&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Sooo… as you can see, we define a regular <code>struct</code> but <em>derive</em> <a href="https://docs.rs/luminance/latest/luminance/shader/program/trait.UniformInterface.html"><code>UniformInterface</code></a>. Deriving the
trait unlocks several annotations you can use via the <code>#[uniform(..)]</code> syntax. Here, we’ll talk
about two:</p>
<ul>
<li><code>#[uniform(unbound)]</code>: that annotation tells luminance that <strong>if</strong> the GPU variable this uniform
variable refers to is <em>inactive</em> or <em>inexistent</em>, no error will be generated. Instead, a special
<em>unbound</em> uniform variable will be emitted. So an <em>unbound</em> <code>Uniform&lt;[[f32; 4]; 4]&gt;</code> means that if the GPU
variable named after that uniform is <em>inactive</em> or <em>inexistent</em>, the resulting <code>Uniform&lt;[[f32; 4]; 4]&gt;</code> will
silently do nothing when you will try to update it. This is a feature you want when you’re
developing or debugging but you should disable that on an end-user application or if you don’t
care about errors for a given variable.</li>
<li><code>#[uniform(name = &quot;foo&quot;)]</code>: rename the field. By default, the GLSL uniform variable will match the
name of the <code>struct</code> field you define. You can change the mapping with that simple annotation.</li>
<li>You can of course mix annotations; e.g. <code>#[uniform(name = &quot;t&quot;, unbound)]</code> is an <em>unbound</em> uniform
variable mapped to a <code>uniform float t</code> in the GLSL code.</li>
</ul>
<p>All we have to do now is to change the type of our <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> to use the uniform interface and
we’re done.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let program = ctxt
    .new_shader_program::&lt;VertexSemantics, (), ShaderInterface&gt;()
    .from_strings(VS_STR, None, None, FS_STR)
    .unwrap()
    .ignore_warnings();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="altering-the-graphics-pipeline"><a class="header" href="#altering-the-graphics-pipeline">Altering the graphics pipeline</a></h1>
<p>Now that we have a shader program that can accept updating our two matrices, we need to actually
pass the matrices down to the GPU so that it can use them when transforming points in the <em>vertex
shader</em>. That is done via the <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html"><code>ShadingGate</code></a>. When you call the <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html#method.shade"><code>ShadingGate::shade</code></a> method,
you must pass a closure that will receive three arguments:</p>
<ul>
<li>A <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.ProgramInterface.html"><code>ProgramInterface</code></a>, that gives you access to an interface to update uniforms.</li>
<li>Your uniform interface.</li>
<li>A <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.RenderGate.html"><code>RenderGate</code></a>, as seen in previous chapters.</li>
</ul>
<p>The <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.ProgramInterface.html"><code>ProgramInterface</code></a> argument allows you to directly manipulate the fields in your
<code>ShaderInterface</code> — here, <code>projection</code> and <code>view</code> that you get as second argument. It also allows
other operations on the <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a>’s <em>uniforms</em> but it’s currently off topic — feel free to read
its documentation if you’re interested, though.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let render = ctxt
      .new_pipeline_gate()
      .pipeline(
        &amp;back_buffer,
        &amp;PipelineState::default().set_clear_color(color),
        |_, mut shd_gate| {
          shd_gate.shade(&amp;mut program, |mut iface, uni, mut rdr_gate| {
            iface.set(&amp;uni.projection, projection.into());
            iface.set(&amp;uni.view, view.into());

            rdr_gate.render(&amp;RenderState::default(), |mut tess_gate| {
              tess_gate.render(&amp;mesh)
            })
          })
        },
      )
      .assume();
<span class="boring">}
</span></code></pre></pre>
<p>It’s as simple as that.</p>
<blockquote>
<p><em>Why the <code>.into()</code> call</em>?</p>
</blockquote>
<p>Because of <a href="https://crates.io/crates/cgmath">cgmath</a>’s type that must be converted to the right array type of our 4×4 matrix.</p>
<p>If you compile and run with the following
<a href="https://phaazon.net/media/uploads/suzanne.obj">suzanne.obj</a> file, you should see this:</p>
<p><img src="imgs/suzanne_flat.png" alt="" /></p>
<p>As you can see, we can guess the monkey silhouette but we don’t actually see any details. In order
to fix that, we will need several things:</p>
<ul>
<li>Vertex normals. Those are used to make light rays <em>bounce</em> over the surface of the object and then
compute angles to determine illumination.</li>
<li>At least one light, to actually “see” the object.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-light"><a class="header" href="#adding-light">Adding light</a></h1>
<p>Light requires <a href="https://en.wikipedia.org/wiki/Normal_(geometry)">normals</a> to be able to compute the shading on surfaces. You might be used to it now:
if we need vertex normals, we need to change our vertex type definition.</p>
<h2 id="rethinking-our-vertex-type"><a class="header" href="#rethinking-our-vertex-type">Rethinking our vertex type</a></h2>
<p>We need normals, so let’s just state it in our vertex type and semantics!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Semantics)]
pub enum VertexSemantics {
  #[sem(name = &quot;position&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexPosition&quot;)]
  Position,
  #[sem(name = &quot;normal&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexNormal&quot;)]
  Normal,
}

#[derive(Clone, Copy, Debug, Vertex)]
#[vertex(sem = &quot;VertexSemantics&quot;)]
struct Vertex {
  position: VertexPosition,
  normal: VertexNormal,
}
<span class="boring">}
</span></code></pre></pre>
<p>If you try to compile now, you will get an error such as the following:</p>
<pre><code>error[E0063]: missing field `normal` in initializer of `Vertex`
   --&gt; src/main.rs:102:26
    |
102 |             let vertex = Vertex { position };
    |                          ^^^^^^ missing `normal`
</code></pre>
<p>Ah, the beauty of strong-typing. :) Let’s fix our loader!</p>
<h2 id="adapting-the-loading-code"><a class="header" href="#adapting-the-loading-code">Adapting the loading code</a></h2>
<p>Let’s take normals into account when loading objects:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for shape in geometry.shapes {
  if let obj::Primitive::Triangle(a, b, c) = shape.primitive {
    for key in &amp;[a, b, c] {
      if let Some(vertex_index) = vertex_cache.get(key) {
        indices.push(*vertex_index);
      } else {
        let p = object.vertices[key.0];
        let n = object.normals[key.2.ok_or(&quot;missing normal for a vertex&quot;.to_owned())?];
        let position = VertexPosition::new([p.x as f32, p.y as f32, p.z as f32]);
        let normal = VertexNormal::new([n.x as f32, n.y as f32, n.z as f32]);
        let vertex = Vertex { position, normal };
        let vertex_index = vertices.len() as VertexIndex;

        vertex_cache.insert(*key, vertex_index);
        vertices.push(vertex);
        indices.push(vertex_index);
      }
    }
  } else {
    return Err(&quot;unsupported non-triangle shape&quot;.to_owned());
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>The main change is this line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = object.normals[key.2.ok_or(&quot;missing normal for a vertex&quot;.to_owned())?];
<span class="boring">}
</span></code></pre></pre>
<p>Basically, the obj format doesn’t force to use normals, so the normal index is optional. In our
case, we can enforce it this way or we could have a fallback normal that would point in the same
direction for all vertices. Up to you to decide.</p>
<h2 id="debugging-normals"><a class="header" href="#debugging-normals">Debugging normals</a></h2>
<p>Let’s make a small and fun debug session to ensure our normals are okay. Modify the vertex and
fragment shader stages to forward the normals and display them.</p>
<pre><code class="language-glsl">// vertex shader
in vec3 position;
in vec3 normal;

out vec3 v_normal;

uniform mat4 projection;
uniform mat4 view;

void main() {
  v_normal = normal;
  gl_Position = projection * view * vec4(position, 1.);
}
</code></pre>
<pre><code class="language-glsl">// fragment shader
in vec3 v_normal;

// we will output a single color
out vec3 frag_color;

void main() {
  // KISS
  frag_color = v_normal;
}
</code></pre>
<p>Recompile and run. You should have something similar to this:</p>
<p><img src="imgs/suzanne_normals.png" alt="" /></p>
<p>How fancy! We can see several interesting things here:</p>
<ul>
<li>The top of the skull of Suzanne is mostly green. It makes sense because in those positions, the
vertex normals are roughly <code>(0, 1, 0)</code>, which when translated to RGB colors is mostly green.</li>
<li>The front face is mostly blue, which makes sense too as the normals there are around <code>(0, 0, 1)</code>,
which is blue in RGB encoding.</li>
<li>The left side (from Suzanne point of view) is mostly red, which makes sense too as it’s
<code>(1, 0, 0)</code> when encoded as RGB.</li>
<li>You can see that normals here are <em>smoothly</em> interpolated — i.e. you don’t actually see the triangles
that compose it. This is due to the fact the normals here were generated so that their directions
generate smooth interpolation across triangles. We could have used flat normals (i.e. face
normals) instead, or we could also explicitly tell the GPU not to perform interpolation in the
shaders. You can try it by using <code>flat out vec3 v_normal;</code> in the vertex shader and
<code>flat in vec3 v_normal;</code> in the fragment shader.</li>
</ul>
<p>Face normals here:</p>
<p><img src="imgs/suzanne_face_normals.png" alt="" /></p>
<h2 id="actually-lighting-the-mesh"><a class="header" href="#actually-lighting-the-mesh">Actually lighting the mesh!</a></h2>
<p>Lighting is now a simple shader concept. Let’s implement a simple lighting effect based on
<a href="https://en.wikipedia.org/wiki/Shading#Directional_lighting">directional lighting</a>. Basically, we can
shade an object by computing the sine of the angles between the light rays and the object normal.
This is called diffused lighting and is an approximation that already gives good results.</p>
<p>The following code is based on the <a href="https://en.wikipedia.org/wiki/Phong_shading">Phong</a> illumination model. It’s basic and we know how to do
way better in terms of realism, but for our case, it’s more than enough.</p>
<pre><code class="language-glsl">in vec3 v_normal;

// we will output a single color
out vec3 frag_color;

void main() {
  // object color
  vec3 obj_color = vec3(.6, .6, .6);

  // light direction
  vec3 light_dir = vec3(0., -1., -.5);

  // diffusion factor (hence the k)
  float kd = dot(v_normal, -light_dir);

  frag_color = obj_color * kd;
}
</code></pre>
<p>And here’s the result:</p>
<p><img src="imgs/suzanne_lit.png" alt="" /></p>
<p>Complete code:</p>
<pre><pre class="playground"><code class="language-rust">use cgmath::{perspective, EuclideanSpace, Matrix4, Point3, Rad, Vector3};
use glfw::{Action, Context as _, Key, WindowEvent};
use luminance_derive::{Semantics, UniformInterface, Vertex};
use luminance_front::context::GraphicsContext;
use luminance_front::pipeline::PipelineState;
use luminance_front::render_state::RenderState;
use luminance_front::shader::Uniform;
use luminance_front::tess::{Interleaved, Mode, Tess, TessError};
use luminance_front::Backend;
use luminance_glfw::GlfwSurface;
use luminance_windowing::{WindowDim, WindowOpt};
use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::Read as _;
use std::path::Path;
use std::process::exit;
use std::time::Instant;
use try_guard::verify;
use wavefront_obj::obj;

const VS_STR: &amp;str = include_str!(&quot;vs.glsl&quot;);
const FS_STR: &amp;str = include_str!(&quot;fs.glsl&quot;);

const FOVY: Rad&lt;f32&gt; = Rad(std::f32::consts::FRAC_PI_2);
const Z_NEAR: f32 = 0.1;
const Z_FAR: f32 = 10.;

#[derive(Debug, UniformInterface)]
struct ShaderInterface {
  #[uniform(unbound)]
  projection: Uniform&lt;[[f32; 4]; 4]&gt;,
  #[uniform(unbound)]
  view: Uniform&lt;[[f32; 4]; 4]&gt;,
}

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Semantics)]
pub enum VertexSemantics {
  #[sem(name = &quot;position&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexPosition&quot;)]
  Position,
  #[sem(name = &quot;normal&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexNormal&quot;)]
  Normal,
}

#[derive(Clone, Copy, Debug, Vertex)]
#[vertex(sem = &quot;VertexSemantics&quot;)]
struct Vertex {
  position: VertexPosition,
  normal: VertexNormal,
}

type VertexIndex = u32;

struct Obj {
  vertices: Vec&lt;Vertex&gt;,
  indices: Vec&lt;VertexIndex&gt;,
}

impl Obj {
  fn to_tess&lt;C&gt;(self, ctxt: &amp;mut C) -&gt; Result&lt;Tess&lt;Vertex, VertexIndex, (), Interleaved&gt;, TessError&gt;
  where
    C: GraphicsContext&lt;Backend = Backend&gt;,
  {
    ctxt
      .new_tess()
      .set_mode(Mode::Triangle)
      .set_vertices(self.vertices)
      .set_indices(self.indices)
      .build()
  }

  fn load&lt;P&gt;(path: P) -&gt; Result&lt;Self, String&gt;
  where
    P: AsRef&lt;Path&gt;,
  {
    let file_content = {
      let mut file = File::open(path).map_err(|e| format!(&quot;cannot open file: {}&quot;, e))?;
      let mut content = String::new();
      file.read_to_string(&amp;mut content).unwrap();
      content
    };
    let obj_set = obj::parse(file_content).map_err(|e| format!(&quot;cannot parse: {:?}&quot;, e))?;
    let objects = obj_set.objects;

    verify!(objects.len() == 1).ok_or(&quot;expecting a single object&quot;.to_owned())?;

    let object = objects.into_iter().next().unwrap();

    verify!(object.geometry.len() == 1).ok_or(&quot;expecting a single geometry&quot;.to_owned())?;

    let geometry = object.geometry.into_iter().next().unwrap();

    println!(&quot;loading {}&quot;, object.name);
    println!(&quot;{} vertices&quot;, object.vertices.len());
    println!(&quot;{} shapes&quot;, geometry.shapes.len());

    // build up vertices; for this to work, we remove duplicated vertices by putting them in a
    // map associating the vertex with its ID
    let mut vertex_cache: HashMap&lt;obj::VTNIndex, VertexIndex&gt; = HashMap::new();
    let mut vertices: Vec&lt;Vertex&gt; = Vec::new();
    let mut indices: Vec&lt;VertexIndex&gt; = Vec::new();

    for shape in geometry.shapes {
      if let obj::Primitive::Triangle(a, b, c) = shape.primitive {
        for key in &amp;[a, b, c] {
          if let Some(vertex_index) = vertex_cache.get(key) {
            indices.push(*vertex_index);
          } else {
            let p = object.vertices[key.0];
            let n = object.normals[key.2.ok_or(&quot;missing normal for a vertex&quot;.to_owned())?];
            let position = VertexPosition::new([p.x as f32, p.y as f32, p.z as f32]);
            let normal = VertexNormal::new([n.x as f32, n.y as f32, n.z as f32]);
            let vertex = Vertex { position, normal };
            let vertex_index = vertices.len() as VertexIndex;

            vertex_cache.insert(*key, vertex_index);
            vertices.push(vertex);
            indices.push(vertex_index);
          }
        }
      } else {
        return Err(&quot;unsupported non-triangle shape&quot;.to_owned());
      }
    }

    Ok(Obj { vertices, indices })
  }
}

fn main() {
  let dim = WindowDim::Windowed {
    width: 960,
    height: 540,
  };
  let surface = GlfwSurface::new_gl33(&quot;Hello, world!&quot;, WindowOpt::default().set_dim(dim));

  match surface {
    Ok(surface) =&gt; {
      eprintln!(&quot;graphics surface created&quot;);
      main_loop(surface);
    }

    Err(e) =&gt; {
      eprintln!(&quot;cannot create graphics surface:\n{}&quot;, e);
      exit(1);
    }
  }
}

fn main_loop(surface: GlfwSurface) {
  let path = env::args()
    .skip(1)
    .next()
    .expect(&quot;first argument must be the path of the .obj file to view&quot;);
  println!(&quot;loading {}&quot;, path);

  let mut ctxt = surface.context;
  let events = surface.events_rx;
  let back_buffer = ctxt.back_buffer().expect(&quot;back buffer&quot;);
  let start_t = Instant::now();

  let mesh = Obj::load(path).unwrap().to_tess(&amp;mut ctxt).unwrap();

  let mut program = ctxt
    .new_shader_program::&lt;VertexSemantics, (), ShaderInterface&gt;()
    .from_strings(VS_STR, None, None, FS_STR)
    .unwrap()
    .ignore_warnings();

  let [width, height] = back_buffer.size();
  let projection = perspective(FOVY, width as f32 / height as f32, Z_NEAR, Z_FAR);

  let view = Matrix4::&lt;f32&gt;::look_at(Point3::new(2., 2., 2.), Point3::origin(), Vector3::unit_y());

  'app: loop {
    // handle events
    ctxt.window.glfw.poll_events();
    for (_, event) in glfw::flush_messages(&amp;events) {
      match event {
        WindowEvent::Close | WindowEvent::Key(Key::Escape, _, Action::Release, _) =&gt; break 'app,
        _ =&gt; (),
      }
    }

    // rendering code goes here
    // get the current time and create a color based on the time
    let t = start_t.elapsed().as_millis() as f32 * 1e-3;
    let color = [t.cos(), t.sin(), 0.5, 1.];

    let render = ctxt
      .new_pipeline_gate()
      .pipeline(
        &amp;back_buffer,
        &amp;PipelineState::default().set_clear_color(color),
        |_, mut shd_gate| {
          shd_gate.shade(&amp;mut program, |mut iface, uni, mut rdr_gate| {
            iface.set(&amp;uni.projection, projection.into());
            iface.set(&amp;uni.view, view.into());

            rdr_gate.render(&amp;RenderState::default(), |mut tess_gate| {
              tess_gate.render(&amp;mesh)
            })
          })
        },
      )
      .assume();

    // swap buffer chains
    if render.is_ok() {
      ctxt.window.swap_buffers();
    } else {
      break 'app;
    }
  }
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
